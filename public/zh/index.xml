<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yufan Chen</title>
    <link>http://localhost:1313/zh/</link>
    <description>Recent content on Yufan Chen</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 07 Sep 2025 14:10:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/zh/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>近期工作的反思</title>
      <link>http://localhost:1313/zh/posts/2025-work-reflection/</link>
      <pubDate>Sun, 07 Sep 2025 14:10:00 +0000</pubDate>
      <guid>http://localhost:1313/zh/posts/2025-work-reflection/</guid>
      <description>&lt;p&gt;加入现在的团队已经三年了。回顾这段时间，有一些事情让我觉得当时应该做得更好。&lt;/p&gt;&#xA;&lt;h2 id=&#34;测试基础设施test-infra&#34;&gt;&#xA;  测试基础设施（Test Infra）&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%b5%8b%e8%af%95%e5%9f%ba%e7%a1%80%e8%ae%be%e6%96%bdtest-infra&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;在项目早期，我们的测试基础设施并不完美，但有一个优势：它与大团队的系统是解耦的。大团队的测试既不稳定又耗费资源，通常需要 10 多个小时才能跑完；而我们的测试套件不到 3 小时就能完成。这大大加快了我们的开发速度。&lt;/p&gt;&#xA;&lt;p&gt;然而，随着业务复杂度不断提升，弊端逐渐显现。我们需要花越来越多的时间去维护自建的测试基础设施，并在其上编写新的测试。模拟依赖服务和数据也变得愈发困难。与此同时，大团队的测试基础设施不断成熟，并且有专门的团队负责维护和改进。&lt;/p&gt;&#xA;&lt;p&gt;这带来了两个问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;高维护成本&lt;/strong&gt;：我们往往花在维护基础设施上的时间比开发新功能还多。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;信号误导&lt;/strong&gt;：由于我们的测试环境没有与整个系统真正集成，有时测试通过了，就让领导和 PM 误以为功能已经“完成”。但一旦进入 staging 环境，伪造依赖的低保真度就会暴露问题，严重干扰了发布流程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;回过头来看，更好的做法是仅将自建的测试环境用作&lt;strong&gt;开发加速器&lt;/strong&gt;，而不是&lt;strong&gt;验证信号&lt;/strong&gt;。功能只有在高保真环境（例如 staging）中通过测试，才能算真正“验证完成”。另外，测试覆盖不足带来的风险也应该明确告知，让 PM 和领导意识到测试资源的缺口，并相应调整优先级。&lt;/p&gt;&#xA;&lt;h2 id=&#34;技术债务tech-debt&#34;&gt;&#xA;  技术债务（Tech Debt）&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%8a%80%e6%9c%af%e5%80%ba%e5%8a%a1tech-debt&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;在紧迫的截止日期下，人们常常会倾向于把长期的修复推迟到后续版本，用临时的 workaround 或 mitigation 来应对当前版本。然而，这往往会带来隐藏的成本。&lt;/p&gt;&#xA;&lt;p&gt;当客户在当前版本中遇到问题时，我们需要花更多时间去指导他们如何使用这些临时方案。并且在升级过程中，这些临时方案会让迁移变得更加复杂，需要额外精力去清理和移除。最终，这些“捷径”往往比一开始就解决问题耗费更多时间和精力。&lt;/p&gt;&#xA;&lt;h2 id=&#34;与上下游团队的定期同步&#34;&gt;&#xA;  与上下游团队的定期同步&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%b8%8e%e4%b8%8a%e4%b8%8b%e6%b8%b8%e5%9b%a2%e9%98%9f%e7%9a%84%e5%ae%9a%e6%9c%9f%e5%90%8c%e6%ad%a5&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;在职业生涯早期，我没有投入足够的精力去与上下游团队定期同步。这导致了几个问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;API 设计不匹配&lt;/strong&gt;：不了解下游团队的业务背景，导致我设计的一些 API 缺乏灵活性。当有新需求时，现有 API 要么无法满足，要么在补丁后变得混乱。同样，由于对上游团队缺乏了解，我也很难影响他们的 API 设计或及时提供反馈，结果我们不得不在本地实现一些 hack 和 workaround。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;无效的开发投入&lt;/strong&gt;：有时我们认为某个功能至关重要，但下游团队却已将其降级或延后。由于我们没有及时获得这些信息，投入了大量精力去开发，最后却完全没被使用。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;集成测试延迟&lt;/strong&gt;：缺乏早期同步，错失了与上下游进行集成测试的机会。结果是问题直到发布前才暴露，被迫在最后时刻修改，增加了交付风险。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;文档与-runbook&#34;&gt;&#xA;  文档与 Runbook&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%96%87%e6%a1%a3%e4%b8%8e-runbook&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;在早期，我常常抗拒写文档或 runbook，认为这是低优先级的事情。但后来我发现，缺乏清晰文档实际上会浪费更多时间。没有文档，队友或运维人员会反复来问同样的问题，而我也要一遍遍解释。&lt;/p&gt;</description>
    </item>
    <item>
      <title>日常随想 - 2025</title>
      <link>http://localhost:1313/zh/posts/micro-blog-2025/</link>
      <pubDate>Sun, 07 Sep 2025 14:10:00 +0000</pubDate>
      <guid>http://localhost:1313/zh/posts/micro-blog-2025/</guid>
      <description>&lt;h3 id=&#34;2025-09-07&#34;&gt;&#xA;  2025-09-07&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#2025-09-07&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;&amp;ldquo;AI Infra要取得好的效果应该要么往上（算法）贴，要么往下（硬件）贴&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;&amp;ldquo;系统级别的优化工作需要AI Infra团队lead。Infra团队在模型设计前期介入会为未来的优化剩下很多精力&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;—— 小宇宙 42章经《关于AI Infra的一切｜对谈阶跃星辰联创朱亦博》&lt;/p&gt;</description>
    </item>
    <item>
      <title>client-go 缓存客户端解析</title>
      <link>http://localhost:1313/zh/posts/k8s-client-go-cache/</link>
      <pubDate>Sun, 13 Jul 2025 14:10:00 +0000</pubDate>
      <guid>http://localhost:1313/zh/posts/k8s-client-go-cache/</guid>
      <description>&lt;p&gt;&lt;strong&gt;概要&lt;/strong&gt;: &lt;code&gt;client-go&lt;/code&gt; 内置了一个基于 SharedInformer 的 &lt;strong&gt;读穿透（read-through）、写旁路（write-around）&lt;/strong&gt; 缓存层。  &lt;code&gt;GET&lt;/code&gt; / &lt;code&gt;LIST&lt;/code&gt; 请求命中内存中的 &lt;strong&gt;Indexer&lt;/strong&gt;，任何 &lt;strong&gt;写操作&lt;/strong&gt; 则直发 API Server。这可以将控制器的读取延迟降低约 &lt;strong&gt;90 %&lt;/strong&gt;，但要避免读到脏数据或掉进性能坑，你必须搞懂 &lt;strong&gt;同步窗口（sync window）&lt;/strong&gt;、&lt;strong&gt;深拷贝&lt;/strong&gt; 以及 &lt;strong&gt;字段索引（field index）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;为什么要用缓存&#34;&gt;&#xA;  为什么要用缓存？&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%bc%93%e5%ad%98&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;Link to heading&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;Link to heading&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;纯 REST（无缓存）&lt;/th&gt;&#xA;          &lt;th&gt;使用 &lt;code&gt;DelegatingClient&lt;/code&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;每次 &lt;code&gt;Get/List&lt;/code&gt; → HTTPS → API Server → etcd&lt;/td&gt;&#xA;          &lt;td&gt;进程内 Map 查询（0 RTT）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;容易触发 QPS / watch 节流&lt;/td&gt;&#xA;          &lt;td&gt;读开销近乎 0，API Server 几乎无压力&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;集群繁忙时尾延迟 ~100 ms&lt;/td&gt;&#xA;          &lt;td&gt;典型延迟 &amp;lt; 1 µs&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;控制器以“读”为主：比对 &lt;strong&gt;期望&lt;/strong&gt; 与 &lt;strong&gt;实际&lt;/strong&gt; 状态，只偶尔写入。缓存把这些读取摊平到内存。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
